-- Roblox Hoopz Script with Mobile UI and Features
-- Supports Delta Executor
-- UI based on Obsidian framework (fallback to basic UI if not available)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Toggles for features
local camlockEnabled = false
local autoPowerEnabled = false
local autoGuardEnabled = false
local speedboostEnabled = false
local autoshootEnabled = false

-- Load Obsidian UI (if available, otherwise use fallback)
local ObsidianUI
pcall(function()
    ObsidianUI = require(game.ReplicatedStorage:WaitForChild("Obsidian"))  -- Adjust path as needed
end)

if ObsidianUI then
    print("Using Obsidian UI framework")
    -- Assuming Obsidian has a function to create a UI; adapt based on actual API
    local ui = ObsidianUI.CreateUI({  -- Hypothetical Obsidian function
        Title = "Hoopz Script",
        Size = UDim2.new(0, 200, 0, 300),
        Position = UDim2.new(0.5, -100, 0.5, -150),
        Buttons = {
            {Text = "Toggle Camlock", Callback = function() camlockEnabled = not camlockEnabled end},
            {Text = "Toggle Auto Power", Callback = function() autoPowerEnabled = not autoPowerEnabled end},
            {Text = "Toggle Auto Guard", Callback = function() autoGuardEnabled = not autoGuardEnabled end},
            {Text = "Toggle Speedboost", Callback = function() speedboostEnabled = not speedboostEnabled end},
            {Text = "Toggle Autoshoot", Callback = function() autoshootEnabled = not autoshootEnabled end},
        }
    })
    ui.Parent = player:WaitForChild("PlayerGui")  -- Parent to PlayerGui for mobile compatibility
else
    print("Obsidian not found; using fallback UI")
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = player:WaitForChild("PlayerGui")
    
    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 200, 0, 300)
    MainFrame.Position = UDim2.new(0.5, -100, 0.5, -150)
    MainFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    MainFrame.Parent = ScreenGui
    
    local buttons = {
        {Text = "Toggle Camlock", Position = UDim2.new(0.5, -90, 0, 10), Callback = function() camlockEnabled = not camlockEnabled end},
        {Text = "Toggle Auto Power", Position = UDim2.new(0.5, -90, 0, 70), Callback = function() autoPowerEnabled = not autoPowerEnabled end},
        {Text = "Toggle Auto Guard", Position = UDim2.new(0.5, -90, 0, 130), Callback = function() autoGuardEnabled = not autoGuardEnabled end},
        {Text = "Toggle Speedboost", Position = UDim2.new(0.5, -90, 0, 190), Callback = function() speedboostEnabled = not speedboostEnabled end},
        {Text = "Toggle Autoshoot", Position = UDim2.new(0.5, -90, 0, 250), Callback = function() autoshootEnabled = not autoshootEnabled end},
    }
    
    for i, btnData in pairs(buttons) do
        local button = Instance.new("TextButton")
        button.Text = btnData.Text
        button.Size = UDim2.new(0, 180, 0, 50)  -- Mobile-friendly size
        button.Position = btnData.Position
        button.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Parent = MainFrame
        
        button.MouseButton1Click:Connect(btnData.Callback)  -- For touch input
    end
end

-- Helper function to find the nearest hoop
local function getNearestHoop()
    local hoops = Workspace:FindFirstChild("Hoops") and Workspace.Hoops:GetChildren() or {}  -- Assuming hoops are in a folder
    local nearestHoop = nil
    local minDistance = math.huge
    local playerPosition = character.HumanoidRootPart.Position
    
    for _, hoop in pairs(hoops) do
        if hoop:IsA("BasePart") then  -- Assuming hoops are BaseParts
            local distance = (hoop.Position - playerPosition).Magnitude
            if distance < minDistance then
                minDistance = distance
                nearestHoop = hoop
            end
        end
    end
    return nearestHoop
end

-- Helper function to find the nearest opponent
local function getNearestOpponent()
    local opponents = {}
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            table.insert(opponents, otherPlayer.Character.HumanoidRootPart)
        end
    end
    
    local nearestOpponent = nil
    local minDistance = math.huge
    local playerPosition = character.HumanoidRootPart.Position
    
    for _, opponentPart in pairs(opponents) do
        local distance = (opponentPart.Position - playerPosition).Magnitude
        if distance < minDistance and distance > 5 then  -- Avoid self
            minDistance = distance
            nearestOpponent = opponentPart
        end
    end
    return nearestOpponent
end

-- Main loop for features
RunService.Heartbeat:Connect(function()
    if not character or not character.Parent then return end  -- Safety check
    
    if speedboostEnabled then
        humanoid.WalkSpeed = 50  -- Boosted speed for mobile
    else
        humanoid.WalkSpeed = 16  -- Default speed
    end
    
    if autoGuardEnabled then
        local nearestOpponent = getNearestOpponent()
        if nearestOpponent then
            -- Move toward opponent (simple pathfinding via Tween)
            local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Linear)
            local tweenGoal = {CFrame = CFrame.new(nearestOpponent.Position)}
            local tween = TweenService:Create(character.HumanoidRootPart, tweenInfo, tweenGoal)
            tween:Play()
        end
    end
    
    if autoPowerEnabled then
        -- Auto adjust power based on distance (hypothetical; adapt to game mechanics)
        local ball = Workspace:FindFirstChild("Ball")  -- Assuming the ball exists
        if ball then
            local hoop = getNearestHoop()
            if hoop then
                local distance = (ball.Position - hoop.Position).Magnitude
                local power = math.clamp(distance / 10, 1, 10)  -- Example: Scale power with distance
                -- Apply power (game-specific; e.g., set a ball property)
                ball:SetAttribute("Power", power)  -- Hypothetical attribute
            end
        end
    end
end)

-- Detect jump and trigger Camlock and Autoshoot
UserInputService.JumpRequest:Connect(function()
    if camlockEnabled then
        local hoop = getNearestHoop()
        if hoop then
            workspace.CurrentCamera.CameraSubject = hoop  -- Lock camera to hoop
            workspace.CurrentCamera.CFrame = CFrame.new(character.HumanoidRootPart.Position, hoop.Position)
        end
    end
    
    if autoshootEnabled then
        local ball = Workspace:FindFirstChild("Ball")  -- Assuming the ball exists
        if ball then
            local hoop = getNearestHoop()
            if hoop then
                -- Simulate shooting the ball toward the hoop
                local direction = (hoop.Position - ball.Position).Unit
                ball.Velocity = direction * 50  -- Hypothetical velocity for shooting
                -- Add any game-specific shoot function here
            end
        end
    end
end)

print("Hoopz Script Loaded! Use the UI to toggle features.")
